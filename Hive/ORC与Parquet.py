
# ORC与Parquet

# 列式存储（Columnar Storage）是一种优化的数据存储方式，与传统的行式存储（Row Storage）相比，列式存储在数据压缩、查询性能、I/O效率等方面具有明显的优势
# 在大数据领域中，ORC（Optimized Row Columnar）和Parquet是两种流行的列式存储格式，它们在数据压缩、查询性能、存储效率等方面有着各自的特点和优势

# ORC官网：https://orc.apache.org/
# Parquet官网：https://parquet.apache.org/

# ORC与Parquet区别
# 相同点：
# + 基于Hadoop文件系统，属于线上格式，可以在节点间传递数据
# + 采用列式二进制存储结构
# + 采用高效的压缩
# + 文件可分割，具有较强的伸缩性和并行处理能力
# + 使用Schema进行自我描述
# + 降低存储成本，减少磁盘I/O成本

# 不同点：
# |           |    ORC                                     |   Parquet|
# |默认压缩     |ZLIB（压缩比较高）                           |  Snappy压缩（压缩比较低）|
# |操作         |  支持delete、update                        |  不支持delete、update|
# |数据类型       | 支持collection、array、map等复杂类型        |  仅支持普通类型|
# |谓词下推       | 支持（减少磁盘I/O成本）                      | 不支持|
# |事务         |  支持ACID（原子性、隔离性、一致性、持久性），但仅限于分桶表    |    不支持事务|
# |兼容性        | Hive、Presto                             |   Impala、Spark、Drill、Arrow|
# |场景         |  Hive                                     |  Spark|


# SQL查询的执行流程

# 参考：https://www.cnblogs.com/antLaddie/p/17175396.html
# 查询是DBMS（OLTP）和OLAP中最常用的操作。我们在理解SELECT语法的时候，还需要了解SELECT执行时的底层原理。只有这样，才能让我们对SQL有更深刻的认识
# 我们只需要记住和理解SELECT查询时的两个顺序：书写顺序和执行顺序
# 执行顺序   书写顺序
# |9     |     SELECT|
# |10    |      DISTINCT|
# |1     |     FROM|
# |3     |     JOIN|
# |2     |     ON|
# |4     |     WHERE|
# |5     |     GROUP BY|
# |7     |     WITH CUBE/ROLLUP|
# |6     |     AGG_FUNC|
# |8     |     HAVING|
# |11    |      ORDER BY|
# |12    |      LIMIT|

#
# SQL执行流程（MySQL）
# 第一步（FROM）：对FROM子句中的前两表执行笛卡尔积（交叉连接），生成虚拟表vt1
# 第二步（ON）：对vt1使用ON筛选器，筛选出满足ON表达式的行，生成虚拟表vt2
# 第三步（JOIN）：保留表中未匹配的行将作为外部行添加到vt2。如果是LEFT JOIN，将左表在第二步中过滤的行添加进来；如果是RIGHT JOIN，将右表在第二步中过滤的行添加进来，生成虚拟表vt3
# 注意：如果FROM子句中有多于两个表，那么就将vt3和第三个表连接计算笛卡尔乘积，生成虚拟表，即重复1-3步骤，最终得到一个新的虚拟表vt3
# 第四步（WHERE）：对vt3使用WHERE筛选器，生成虚拟表vt4
# 第五步（GROUP BY）：GROUP BY子句将对vt4按指定列唯一值进行分组，每一组仅包含一行，得到虚拟表vt5
# 注意：由于vt5的结果集中每个组只包含一行，因此后面的操作只能得到vt5的列或基于每组内的一行数据操作
# 第六步（聚合函数）：对每组内的一行数据执行聚合函数，生成虚拟表vt6
# 第七步（WITH CUBE/ROLLUP）：如果与GROUP BY一起使用，计算不同维度层次结构级别下的聚合（vt6）
# 第八步（HAVING）：对vt5的每组数据或vt6聚合结果应用HAVING筛选器，生成虚拟表vt7
# 注意：这一步是第一个可以使用SELECT列的别名的步骤
# 第九步（SELECT）：从vt7中筛选列，生成虚拟表vt8
# 第十步（DISTINCT）：移除vt8中相同的行（去重），生成虚拟表vt9
# 注意：如果执行了GROUP BY，DISTINCT将是多余的。因为GROUP BY将列中相同值的分成一组，同时只为每一组返回一行记录，那么所有的记录都将是不相同的
# 第十一步（ORDER BY）：对vt9按指定字段排序，生成一个游标vc10，而不是虚拟表
# 注意：SQL是基于集合理论的，集合不会预先对它进行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询返回一个游标对象，这个对象是包含特定物理顺序的逻辑组织。正因为返回值是游标，所以使用ORDER BY子句查询不能应用于表达式。排序是很需要成本的，除非必须要排序，否则最好不要指定ORDER BY。另外，这一步是第二个可以使用SELECT列的别名的步骤
# 第十二步（LIMIT）：从游标vc10开始处选择指定数量的行，生成最终表返回给客户端

# WHERE与ON的使用
# 对于包含OUTER JOIN子句的查询，到底是在ON筛选器里指定逻辑过滤条件还是用WHERE筛选器指定逻辑过滤条件呢？

# 实际上，ON和WHERE的最大区别在于，如果在ON中应用逻辑表达式，那么在第三步OUTER JOIN中还可以把过滤的行再次添加回来匹配。而WHERE一旦被过滤就找不回来了
# 简单来说就是，当有外关联表时（左连接和右连接），ON主要是针对外关联表进行筛选，主表信息保留；当不是外关联表时，两者作用相同
# 例如左外连接时，首先执行ON，筛选掉外关连表中不符合ON表达式的数据，JOIN时再将这部分数据进行与主表匹配；而WHERE的筛选是对ON关联后的结果进行整体筛选

# 假设有一个学生表（班级，ID，姓名）和一个成绩表(ID，姓名，成绩)，现在需要返回一个X班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到预期的结果，首先就需要在ON子句指定学生表和成绩表的关系（学生.ID=成绩.ID）
# 如果在ON子句中应用学生.班级=X，LEFT JION会把班级X在第二步中过滤的记录找回主表（保留表）匹配，匹配不到的数据补NULL
# 如果在WHERE中筛选学生.班级=X，则只打印X班级的学生信息，其它班级的学生信息则会被永久过滤

# ON会显示所有匹配条件的值，不匹配条件的数据补NULL；WHERE只显示满足条件的数据



